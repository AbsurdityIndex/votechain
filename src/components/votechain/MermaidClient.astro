<script is:inline>
  document.addEventListener('DOMContentLoaded', function () {
    var preBlocks = document.querySelectorAll('pre[data-language="mermaid"]');
    function showMermaidSourceFallback() {
      if (!preBlocks || !preBlocks.length) return;
      preBlocks.forEach(function (pre) {
        pre.style.display = '';
      });
    }
    if (preBlocks.length === 0) return;

    var MERMAID_CDN_CANDIDATES = ['/votechain/mermaid.min.js', '/mermaid.min.js'];
    var MERMAID_ICON_PREFIX = '/evidence/icons/';
    var MERMAID_ICON_PREFIX_LEGACY = '/votechain/evidence/icons/';

    function isThenable(x) {
      return !!x && (typeof x === 'object' || typeof x === 'function') && typeof x.then === 'function';
    }

    function clamp(value, min, max) {
      return Math.min(max, Math.max(min, value));
    }

    function deriveAssetBaseFromPath(pathname) {
      if (pathname === '/votechain' || pathname.indexOf('/votechain/') === 0) return '/votechain';
      return '';
    }

    function getMermaidAssetBase() {
      return window.__votechainAssetBase || deriveAssetBaseFromPath(window.location.pathname);
    }

    function setMermaidAssetBaseFromScript(scriptPath) {
      if (!scriptPath) return;
      var marker = '/mermaid.min.js';
      if (scriptPath.indexOf(marker) === scriptPath.length - marker.length) {
        window.__votechainAssetBase = scriptPath.substring(0, scriptPath.length - marker.length) || '';
      } else {
        window.__votechainAssetBase = deriveAssetBaseFromPath(window.location.pathname);
      }
    }

    function normalizeText(input) {
      return String(input || '')
        .toLowerCase()
        .replace(/\s+/g, ' ')
        .trim();
    }

    function normalizeNodeId(nodeId) {
      if (!nodeId) return '';
      return String(nodeId)
        .replace(/^\s+|\s+$/g, '')
        .replace(/^['"]|['"]$/g, '')
        .replace(/\s+/g, ' ')
        .trim();
    }

    function parseFlowchartNodeKey(nodeId) {
      var raw = normalizeNodeId(nodeId);
      if (!raw) return null;

      // Mermaid often emits flowchart ids as flowchart-<KEY>-<INDEX>.
      if (raw.indexOf('flowchart-') === 0) {
        var parts = raw.split('-');
        if (parts.length >= 2) {
          parts.shift(); // flowchart
          if (/^\d+$/.test(parts[parts.length - 1])) parts.pop();
          if (parts.length > 0) return parts.join('-');
        }
      }

      // Some builds output legacy/generated ids with a numeric tail, e.g. NODE-0.
      var dashParts = raw.split('-');
      if (dashParts.length > 1 && /^\d+$/.test(dashParts[dashParts.length - 1])) {
        dashParts.pop();
        if (dashParts.length > 0) return dashParts.join('-');
      }

      // Direct source IDs, including explicit names such as PMETA/B1/ING.
      if (/^[A-Za-z0-9_\-.:]+$/.test(raw)) return raw;
      return null;
    }

    function parseFlowchartEdge(edgeId) {
      var raw = normalizeNodeId(edgeId);
      if (!raw) return null;
      if (raw.indexOf('L_') !== 0) return null;
      var parts = raw.split('_');
      // Expected: L_<FROM>_<TO>_<INDEX>. FROM/TO should not contain underscores.
      if (parts.length < 4) return null;
      return { from: parts[1] || null, to: parts[2] || null };
    }

    function extractDiagramIdFromSource(sourceText) {
      var text = String(sourceText || '');
      if (!text) return null;
      var lines = text.split('\n').slice(0, 10);
      for (var i = 0; i < lines.length; i++) {
        var m = lines[i].match(/^\s*%%\s*diagram-id:\s*([a-z0-9][a-z0-9_-]{1,80})\s*$/i);
        if (m && m[1]) return m[1];
      }
      return null;
    }

    function dedupeStrings(items) {
      var out = [];
      for (var i = 0; i < items.length; i++) {
        var value = String(items[i] || '');
        if (!value) continue;
        if (out.indexOf(value) !== -1) continue;
        out.push(value);
      }
      return out;
    }

    function buildNodeIconUrlCandidates(rawSrc) {
      if (!rawSrc) return null;
      var scriptBase = getMermaidAssetBase();
      var hasOrigin = rawSrc.indexOf(window.location.origin) === 0;
      var iconName = null;
      if (rawSrc.indexOf(MERMAID_ICON_PREFIX) === 0) {
        iconName = rawSrc.substring(MERMAID_ICON_PREFIX.length);
      } else if (rawSrc.indexOf(MERMAID_ICON_PREFIX_LEGACY) === 0) {
        iconName = rawSrc.substring(MERMAID_ICON_PREFIX_LEGACY.length);
      } else if (hasOrigin && rawSrc.indexOf(window.location.origin + MERMAID_ICON_PREFIX) === 0) {
        iconName = rawSrc.substring((window.location.origin + MERMAID_ICON_PREFIX).length);
      } else if (hasOrigin && rawSrc.indexOf(window.location.origin + MERMAID_ICON_PREFIX_LEGACY) === 0) {
        iconName = rawSrc.substring((window.location.origin + MERMAID_ICON_PREFIX_LEGACY).length);
      }
      if (!iconName) return null;
      return dedupeStrings([
        scriptBase + MERMAID_ICON_PREFIX + iconName,
        MERMAID_ICON_PREFIX_LEGACY + iconName,
      ]);
    }

    function normalizeMermaidSourceIcons(sourceText) {
      var base = getMermaidAssetBase();
      if (!sourceText) return sourceText;
      return String(sourceText).replace(
        /src=(["'])(\/(?:votechain\/)?evidence\/icons\/[^"']+)\1/g,
        function (_, quote, srcValue) {
          var srcPrefix = "src=";
          var marker = '/evidence/icons/';
          var iconStart = srcValue.indexOf(marker);
          if (iconStart === -1) return srcPrefix + quote + srcValue + quote;
          var iconName = srcValue.substring(iconStart + marker.length);
          return srcPrefix + quote + base + MERMAID_ICON_PREFIX + iconName + quote;
        }
      );
    }

    function bindNodeIconFallback(img) {
      if (!img || img.dataset.votechainNodeIconHandled === '1') return;

      var candidates = buildNodeIconUrlCandidates(img.getAttribute('src'));
      if (!candidates || candidates.length < 2) return;

      img.dataset.votechainNodeIconHandled = '1';
      img.dataset.votechainNodeIconCandidates = candidates.join('|');
      img.dataset.votechainNodeIconIndex = '0';

      var currentIndex = 0;
      img.src = candidates[currentIndex];

      function onNodeIconError() {
        var nextIndex = currentIndex + 1;
        if (nextIndex >= candidates.length) return;
        currentIndex = nextIndex;
        img.dataset.votechainNodeIconIndex = String(currentIndex);
        img.src = candidates[currentIndex];
      }

      img.addEventListener('error', onNodeIconError);
      img.addEventListener(
        'load',
        function () {
          img.removeEventListener('error', onNodeIconError);
        },
        { once: true }
      );
    }

    function repairMermaidNodeIcons(diagramEl) {
      if (!diagramEl || !diagramEl.querySelectorAll) return;
      var images = diagramEl.querySelectorAll('img');
      if (!images || images.length === 0) return;
      for (var i = 0; i < images.length; i++) {
        bindNodeIconFallback(images[i]);
      }
    }

    function getNodeLabelText(nodeEl) {
      if (!nodeEl) return '';
      var fo = nodeEl.querySelector('foreignObject');
      var raw = fo ? fo.textContent : nodeEl.textContent;
      return String(raw || '').replace(/\s+/g, ' ').trim();
    }

    function inferTitleForDiagram(diagramEl) {
      if (!diagramEl) return 'Diagram inspector';
      var root = diagramEl.closest('.bill-content');
      if (!root) return 'Diagram inspector';
      var headings = root.querySelectorAll('h2, h3, h4');
      var best = null;
      headings.forEach(function (h) {
        if (!(h instanceof HTMLElement)) return;
        var pos = h.compareDocumentPosition(diagramEl);
        // If the diagram is after this heading, keep it as the best match so far.
        if (pos & Node.DOCUMENT_POSITION_FOLLOWING) best = h;
      });
      var txt = best ? best.textContent : '';
      txt = String(txt || '').trim();
      return txt || 'Diagram inspector';
    }

    function inferMermaidTypeFromSource(sourceText) {
      var text = String(sourceText || '');
      if (!text) return 'Diagram';

      var lines = text.split('\n');
      var line;
      for (var i = 0; i < lines.length; i++) {
        line = String(lines[i] || '').trim();
        if (!line || line.indexOf('%%') === 0) continue;
        break;
      }
      if (!line) return 'Diagram';

      var tokenMatch = line.match(/^([A-Za-z][A-Za-z0-9_-]*)/);
      if (!tokenMatch || !tokenMatch[1]) return 'Diagram';
      var token = tokenMatch[1];

      var explicitMap = {
        graph: 'Flowchart',
        flowchart: 'Flowchart',
        sequenceDiagram: 'Sequence',
        sequence: 'Sequence',
        stateDiagram: 'State',
        stateDiagramV2: 'State',
        classDiagram: 'Class',
        erDiagram: 'ER',
        gantt: 'Gantt',
        journey: 'Journey',
        pie: 'Pie',
        gitGraph: 'Git',
        mindmap: 'Mindmap',
        requirementDiagram: 'Requirement',
        packet: 'Packet',
        timeline: 'Timeline',
        block: 'Block',
      };
      if (explicitMap[token]) return explicitMap[token];

      var formatted = token
        .replace(/([a-z])([A-Z])/g, '$1 $2')
        .replace(/[_-]/g, ' ')
        .trim();
      if (!formatted) return token;
      return formatted.charAt(0).toUpperCase() + formatted.slice(1);
    }

    function getDiagramMetadata(diagramEl) {
      if (!diagramEl) {
        return {
          titleBase: 'Diagram inspector',
          typeLabel: 'Diagram',
          sourceId: '',
        };
      }

      var titleBase = inferTitleForDiagram(diagramEl);
      var sourceText = diagramEl.getAttribute('data-mermaid-source') || '';
      var typeLabel = inferMermaidTypeFromSource(sourceText);
      var sourceId = String(diagramEl.getAttribute('data-diagram-id') || '').trim();

      return {
        titleBase: titleBase,
        typeLabel: typeLabel,
        sourceId: sourceId,
      };
    }

    function truncateForUi(value, maxLength) {
      var text = String(value || '').trim();
      var max = typeof maxLength === 'number' && maxLength > 0 ? maxLength : 0;
      if (!max || text.length <= max) return text;
      return text.slice(0, Math.max(0, max - 1)) + '…';
    }

    function createModal() {
      var overlay = document.createElement('div');
      overlay.className = 'diagram-inspector-overlay';
      overlay.setAttribute('aria-hidden', 'true');

      var dialog = document.createElement('div');
      dialog.className = 'diagram-inspector';
      dialog.setAttribute('role', 'dialog');
      dialog.setAttribute('aria-modal', 'true');

      var header = document.createElement('div');
      header.className = 'diagram-inspector-header';

      var titleRow = document.createElement('div');
      titleRow.className = 'diagram-inspector-title-row';

      var titleWrap = document.createElement('div');
      titleWrap.className = 'diagram-inspector-title-wrap';

      var title = document.createElement('div');
      title.className = 'diagram-inspector-title';
      title.textContent = 'Diagram inspector';

      var meta = document.createElement('div');
      meta.className = 'diagram-inspector-meta';
      meta.textContent = 'Diagram';

      titleWrap.appendChild(title);
      titleWrap.appendChild(meta);
      titleRow.appendChild(titleWrap);

      var scaleBadge = document.createElement('div');
      scaleBadge.className = 'diagram-inspector-scale';
      scaleBadge.textContent = '100%';

      titleRow.appendChild(scaleBadge);

      var statusRow = document.createElement('div');
      statusRow.className = 'diagram-inspector-status-row';

      var diagramInfo = document.createElement('div');
      diagramInfo.className = 'diagram-inspector-diagram-info';
      diagramInfo.textContent = 'No diagram selected';

      var navPath = document.createElement('div');
      navPath.className = 'diagram-inspector-nav-path';
      navPath.textContent = 'Path: start';

      var focusState = document.createElement('div');
      focusState.className = 'diagram-inspector-focus';
      focusState.textContent = 'Focus: none';

      statusRow.appendChild(diagramInfo);
      statusRow.appendChild(navPath);
      statusRow.appendChild(focusState);

      var liveStatus = document.createElement('div');
      liveStatus.className = 'diagram-inspector-live-status';
      liveStatus.setAttribute('role', 'status');
      liveStatus.setAttribute('aria-live', 'polite');
      liveStatus.setAttribute('aria-atomic', 'true');
      liveStatus.textContent = '';

      var searchWrap = document.createElement('div');
      searchWrap.className = 'diagram-inspector-search';

      var searchInput = document.createElement('input');
      searchInput.className = 'diagram-inspector-search-input';
      searchInput.type = 'search';
      searchInput.placeholder = 'Find node (e.g., ENR, VCLW, STH)';
      searchInput.setAttribute('aria-label', 'Find node');
      searchInput.disabled = true;

      var controls = document.createElement('div');
      controls.className = 'diagram-inspector-controls';

      var hints = document.createElement('div');
      hints.className = 'diagram-inspector-hints';
      hints.innerHTML = [
        '<span><kbd>+</kbd>/<kbd>-</kbd> zoom</span>',
        '<span><kbd>0</kbd> fit</span>',
        '<span><kbd>r</kbd> reset fit</span>',
        '<span><kbd>Tab</kbd> cycle controls</span>',
        '<span><kbd>/</kbd> focus search</span>',
        '<span><kbd>f</kbd> focus field</span>',
        '<span><kbd>c</kbd> clear focus</span>',
        '<span><kbd>right-click</kbd> decompose</span>',
        '<span><kbd>Esc</kbd> close</span>',
      ].join('');

      function makeBtn(label, action) {
        var b = document.createElement('button');
        b.type = 'button';
        b.className = 'diagram-inspector-btn';
        b.textContent = label;
        b.setAttribute('data-action', action);
        return b;
      }

      var btnFind = makeBtn('Find', 'find');
      var btnBack = makeBtn('Back', 'back');
      var btnDecompose = makeBtn('Decompose', 'decompose');
      var btnClearFocus = makeBtn('Clear focus', 'clearFocus');
      btnFind.disabled = true;
      btnBack.disabled = true;
      btnDecompose.disabled = true;
      btnClearFocus.disabled = true;

      var btnFit = makeBtn('Fit', 'fit');
      var btnReset = makeBtn('Reset', 'reset');
      var btnZoomOut = makeBtn('Zoom -', 'zoomOut');
      var btnZoomIn = makeBtn('Zoom +', 'zoomIn');
      var btnClose = makeBtn('Close', 'close');
      btnClose.classList.add('diagram-inspector-btn-primary');

      searchWrap.appendChild(searchInput);
      searchWrap.appendChild(btnFind);

      var groupNav = document.createElement('div');
      groupNav.className = 'diagram-inspector-control-group';
      groupNav.appendChild(btnBack);
      groupNav.appendChild(btnDecompose);
      groupNav.appendChild(btnClearFocus);

      var groupSearch = document.createElement('div');
      groupSearch.className = 'diagram-inspector-control-group';
      groupSearch.appendChild(searchWrap);

      var groupZoom = document.createElement('div');
      groupZoom.className = 'diagram-inspector-control-group';
      groupZoom.appendChild(btnFit);
      groupZoom.appendChild(btnReset);
      groupZoom.appendChild(btnZoomOut);
      groupZoom.appendChild(btnZoomIn);

      var groupClose = document.createElement('div');
      groupClose.className = 'diagram-inspector-control-group';
      groupClose.appendChild(btnClose);

      controls.appendChild(groupNav);
      controls.appendChild(groupSearch);
      controls.appendChild(groupZoom);
      controls.appendChild(groupClose);

      header.appendChild(titleRow);
      header.appendChild(statusRow);
      header.appendChild(liveStatus);
      header.appendChild(controls);
      header.appendChild(hints);

      var viewport = document.createElement('div');
      viewport.className = 'diagram-inspector-viewport';

      dialog.appendChild(header);
      dialog.appendChild(viewport);

      overlay.appendChild(dialog);
      document.body.appendChild(overlay);

      return {
        overlay: overlay,
        dialog: dialog,
        viewport: viewport,
        title: title,
        meta: meta,
        diagramInfo: diagramInfo,
        navPath: navPath,
        focusState: focusState,
        liveStatus: liveStatus,
        searchInput: searchInput,
        btnFind: btnFind,
        btnBack: btnBack,
        btnDecompose: btnDecompose,
        btnClearFocus: btnClearFocus,
        btnClose: btnClose,
        scaleBadge: scaleBadge,
        hints: hints,
      };
    }

    // Lazy-created modal so we only pay DOM cost on pages with diagrams.
    var modal = null;
    var active = null;
    var focusIndexCache = new WeakMap();
    var diagramNavStack = [];
    var modalReturnTarget = null;

    // Right-click "decomposition" jumps from a node to a deeper/alternate diagram view.
    // This stays lightweight: Mermaid remains the canonical representation.
    var DECOMPOSE_TO_DIAGRAM_ID = {
      // VoteChain consortium detail
      VCLN: 'votechain-consortium-74',

      // Raspberry Pi integration drill-down paths.
      PMETA: 'pi-machine-wiring',
      XMETA: 'pi-network-segmentation',
      AMETA: 'pi-compose-placement',
      PSW: 'pi-network-segmentation',
      VMETA: 'pi-test-cycle',
      BMETA: 'pi-test-cycle',
      CMETA: 'pi-compose-placement',

      // EWP pipeline detail (sequence view)
      VC1: 'ewp-cast-to-tally-sequence',
      VC2: 'ewp-cast-to-tally-sequence',
      VC3: 'ewp-cast-to-tally-sequence',
      G1: 'ewp-cast-to-tally-sequence',
      G2: 'ewp-cast-to-tally-sequence',
      G3: 'ewp-cast-to-tally-sequence',
      BLOG: 'ewp-cast-to-tally-sequence',
      STH: 'ewp-cast-to-tally-sequence',
      TS: 'ewp-cast-to-tally-sequence',
      TP: 'ewp-cast-to-tally-sequence',
      M: 'ewp-cast-to-tally-sequence',
    };

    // Pan/zoom state for the active diagram SVG in the modal viewport.
    var panZoom = {
      svg: null,
      scale: 1,
      tx: 0,
      ty: 0,
      pointers: new Map(),
      dragStart: null,
      pinchStart: null,
      ignoreClick: false,
    };

    // When a diagram is moved into the fullscreen inspector we need the SVG to have a stable
    // intrinsic size; Mermaid's responsive sizing can otherwise cause "Fit" to mis-measure and
    // appear clipped/cut off. We temporarily size the SVG to its viewBox (px) and restore on close.
    var svgInspectorStyleCache = new WeakMap();

    function prepareSvgForInspector(svg) {
      if (!svg) return;
      if (!(svg instanceof SVGSVGElement)) return;
      if (svgInspectorStyleCache.has(svg)) return;

      svgInspectorStyleCache.set(svg, {
        width: svg.style.width,
        height: svg.style.height,
        maxWidth: svg.style.maxWidth,
        maxHeight: svg.style.maxHeight,
        display: svg.style.display,
      });

      var vb = svg.viewBox && svg.viewBox.baseVal ? svg.viewBox.baseVal : null;
      if (vb && vb.width > 0 && vb.height > 0) {
        svg.style.width = vb.width + 'px';
        svg.style.height = vb.height + 'px';
      }

      svg.style.maxWidth = 'none';
      svg.style.maxHeight = 'none';
      svg.style.display = 'block';
    }

    function restoreSvgAfterInspector(svg) {
      if (!svg) return;
      if (!(svg instanceof SVGSVGElement)) return;
      var prev = svgInspectorStyleCache.get(svg);
      if (!prev) return;
      svg.style.width = prev.width || '';
      svg.style.height = prev.height || '';
      svg.style.maxWidth = prev.maxWidth || '';
      svg.style.maxHeight = prev.maxHeight || '';
      svg.style.display = prev.display || '';
      svgInspectorStyleCache.delete(svg);
    }

    function applyTransform() {
      if (!panZoom.svg) return;
      panZoom.svg.style.transformOrigin = '0 0';
      panZoom.svg.style.transform =
        'translate(' + panZoom.tx + 'px, ' + panZoom.ty + 'px) scale(' + panZoom.scale + ')';
      panZoom.svg.style.willChange = 'transform';
      updateScaleBadge();
    }

    function updateScaleBadge() {
      if (!modal || !modal.scaleBadge) return;
      var pct = Math.round(panZoom.scale * 100);
      modal.scaleBadge.textContent = String(pct) + '%';
    }

    function updateLiveStatus(message) {
      if (!modal || !modal.liveStatus) return;
      modal.liveStatus.textContent = String(message || '');
    }

    function getInspectorPathLabel() {
      if (!active) return 'Path: root';

      var labels = [];
      for (var i = 0; i < diagramNavStack.length; i++) {
        var entry = diagramNavStack[i];
        if (!entry) continue;
        var stackLabel = entry.titleBase || 'Diagram';
        labels.push(truncateForUi(stackLabel, 18));
      }
      labels.push(truncateForUi(active.titleBase || 'Diagram', 18));
      return 'Path: ' + labels.join(' → ');
    }

    function renderDiagramInfo() {
      if (!modal) return;
      if (!active) {
        modal.title.textContent = 'Diagram inspector';
        modal.meta.textContent = 'Diagram';
        modal.diagramInfo.textContent = 'No diagram selected';
        modal.navPath.textContent = 'Path: start';
        return;
      }

      var base = truncateForUi(active.titleBase || 'Diagram inspector', 72);
      modal.title.textContent = base;
      modal.meta.textContent = active.diagramType || 'Diagram';

      var id = active.diagramId || '';
      var idText = id ? ' • ID: ' + id : '';
      if (active.focusIndex) {
        modal.diagramInfo.textContent =
          (active.focusIndex.nodes.length + ' nodes • ' + active.focusIndex.edges.length + ' edges') + idText;
      } else {
        modal.diagramInfo.textContent = idText || 'No selectable elements discovered';
      }

      modal.navPath.textContent = getInspectorPathLabel();
    }

    function centerOnElement(el) {
      if (!modal || !active || !panZoom.svg || !el) return;
      if (!(el instanceof Element)) return;
      var viewportRect = modal.viewport.getBoundingClientRect();
      var rect = el.getBoundingClientRect();
      if (rect.width === 0 && rect.height === 0) return;

      var cx = rect.left - viewportRect.left + rect.width / 2;
      var cy = rect.top - viewportRect.top + rect.height / 2;
      panZoom.tx += viewportRect.width / 2 - cx;
      panZoom.ty += viewportRect.height / 2 - cy;
      applyTransform();
    }

    function buildFocusIndex(svg) {
      if (!svg) return null;

      var nodeEls = svg.querySelectorAll('g.node');
      var edgePathEls = svg.querySelectorAll('path.flowchart-link[id^="L_"]');
      if (nodeEls.length === 0) return null;

      var index = {
        svg: svg,
        nodes: [],
        nodeByKey: new Map(),
        nodeSearch: [],
        edges: [],
        edgeById: new Map(),
        edgesByNode: new Map(),
        focusNode: null,
        focusEdge: null,
        _wired: false,
      };

      nodeEls.forEach(function (nodeEl) {
        if (!(nodeEl instanceof SVGGElement)) return;
        var key = parseFlowchartNodeKey(nodeEl.getAttribute('id'));
        if (!key) return;
        var label = getNodeLabelText(nodeEl);
        var record = { key: key, label: label, el: nodeEl };
        index.nodes.push(record);
        index.nodeByKey.set(key, record);
        index.nodeSearch.push({ key: key, keyNorm: normalizeText(key), labelNorm: normalizeText(label) });
      });
      if (index.nodes.length === 0) return null;

      function addEdgeToNode(nodeKey, edgeRecord) {
        if (!nodeKey) return;
        var list = index.edgesByNode.get(nodeKey);
        if (!list) {
          list = [];
          index.edgesByNode.set(nodeKey, list);
        }
        list.push(edgeRecord);
      }

      edgePathEls.forEach(function (pathEl) {
        if (!(pathEl instanceof SVGPathElement)) return;
        var edgeId = pathEl.getAttribute('id') || pathEl.getAttribute('data-id') || '';
        var parsed = parseFlowchartEdge(edgeId);
        if (!parsed || !parsed.from || !parsed.to) return;
        var record = { id: edgeId, from: parsed.from, to: parsed.to, pathEl: pathEl, labelEls: [] };
        index.edges.push(record);
        index.edgeById.set(edgeId, record);
        addEdgeToNode(parsed.from, record);
        addEdgeToNode(parsed.to, record);
      });

      // Index edge labels by data-id (matches edge path id).
      var labelInnerEls = svg.querySelectorAll('g.edgeLabel .label[data-id]');
      labelInnerEls.forEach(function (labelEl) {
        if (!(labelEl instanceof SVGGElement)) return;
        var edgeId = labelEl.getAttribute('data-id') || '';
        if (!edgeId) return;
        var edge = index.edgeById.get(edgeId);
        if (!edge) return;
        var wrapper = labelEl.closest('g.edgeLabel') || labelEl;
        if (wrapper) edge.labelEls.push(wrapper);
      });

      return index;
    }

    function clearDiagramFocus(index) {
      if (!index) return;
      index.focusNode = null;
      index.focusEdge = null;

      index.nodes.forEach(function (n) {
        n.el.classList.remove('diagram-dim', 'diagram-highlight', 'diagram-selected');
      });
      index.edges.forEach(function (e) {
        e.pathEl.classList.remove('diagram-dim', 'diagram-highlight', 'diagram-selected');
        e.labelEls.forEach(function (lbl) {
          lbl.classList.remove('diagram-dim', 'diagram-highlight', 'diagram-selected');
        });
      });
    }

    function applyDiagramFocus(index, opts) {
      if (!index) return;
      var nodes = opts.nodes || new Set();
      var edges = opts.edges || new Set();
      var selectedNode = opts.selectedNode || null;
      var selectedEdge = opts.selectedEdge || null;

      index.nodes.forEach(function (n) {
        n.el.classList.add('diagram-dim');
        n.el.classList.remove('diagram-highlight', 'diagram-selected');
      });
      index.edges.forEach(function (e) {
        e.pathEl.classList.add('diagram-dim');
        e.pathEl.classList.remove('diagram-highlight', 'diagram-selected');
        e.labelEls.forEach(function (lbl) {
          lbl.classList.add('diagram-dim');
          lbl.classList.remove('diagram-highlight', 'diagram-selected');
        });
      });

      nodes.forEach(function (nodeKey) {
        var n = index.nodeByKey.get(nodeKey);
        if (!n) return;
        n.el.classList.remove('diagram-dim');
        n.el.classList.add('diagram-highlight');
      });

      edges.forEach(function (edgeId) {
        var e = index.edgeById.get(edgeId);
        if (!e) return;
        e.pathEl.classList.remove('diagram-dim');
        e.pathEl.classList.add('diagram-highlight');
        e.labelEls.forEach(function (lbl) {
          lbl.classList.remove('diagram-dim');
          lbl.classList.add('diagram-highlight');
        });
      });

      if (selectedNode) {
        var sn = index.nodeByKey.get(selectedNode);
        if (sn) sn.el.classList.add('diagram-selected');
      }
      if (selectedEdge) {
        var se = index.edgeById.get(selectedEdge);
        if (se) {
          se.pathEl.classList.add('diagram-selected');
          se.labelEls.forEach(function (lbl) {
            lbl.classList.add('diagram-selected');
          });
        }
      }
    }

    function updateFocusUi() {
      if (!modal) return;
      if (!active || !active.focusIndex) {
        modal.searchInput.disabled = true;
        modal.btnFind.disabled = true;
        modal.btnClearFocus.disabled = true;
        modal.btnDecompose.disabled = true;
        modal.btnDecompose.textContent = 'Decompose';
        modal.btnDecompose.setAttribute('title', 'Select a node first to enable drill-down');
        modal.focusState.textContent = 'Focus: none';
        updateLiveStatus('');
        renderDiagramInfo();
        updateNavUi();
        return;
      }

      modal.searchInput.disabled = false;
      modal.btnFind.disabled = false;

      var hasFocus = !!(active.focusIndex.focusNode || active.focusIndex.focusEdge);
      modal.btnClearFocus.disabled = !hasFocus;
      if (!hasFocus) {
        modal.focusState.textContent = 'Focus: none';
      } else if (active.focusIndex.focusNode) {
        modal.focusState.textContent = 'Focus: node ' + active.focusIndex.focusNode;
      } else if (active.focusIndex.focusEdge) {
        modal.focusState.textContent = 'Focus: transition ' + active.focusIndex.focusEdge;
      }

      var focusNodeKey = active.focusIndex.focusNode || '';
      var decomposeInfo = getDecomposeInfoForNode(focusNodeKey);
      if (decomposeInfo) {
        modal.btnDecompose.disabled = false;
        var decomposeLabel =
          'Decompose ' + focusNodeKey + ' → ' + truncateForUi(decomposeInfo.title, 28);
        modal.btnDecompose.textContent = decomposeLabel;
        modal.btnDecompose.setAttribute(
          'title',
          'Open detail diagram: ' + decomposeInfo.title + ' (' + decomposeInfo.diagramId + ')',
        );
      } else {
        modal.btnDecompose.disabled = !focusNodeKey;
        modal.btnDecompose.textContent = focusNodeKey ? 'Decompose (no detail map)' : 'Decompose';
        modal.btnDecompose.setAttribute(
          'title',
          focusNodeKey
            ? 'No detail diagram mapped for ' + focusNodeKey
            : 'Select a node first to enable drill-down',
        );
      }
      if (hasFocus && active.focusIndex.focusNode) {
        modal.searchInput.value = active.focusIndex.focusNode;
      }

      if (hasFocus) {
        if (active.focusIndex.focusNode && decomposeInfo) {
          updateLiveStatus('Focused: node ' + focusNodeKey + '  •  decompose to ' + decomposeInfo.title);
        } else if (active.focusIndex.focusNode) {
          updateLiveStatus('Focused: node ' + focusNodeKey + '  •  no linked detail diagram');
        } else {
          updateLiveStatus('Focused: transition ' + active.focusIndex.focusEdge);
        }
      } else {
        updateLiveStatus('');
      }

      renderDiagramInfo();
      updateNavUi();
    }

    function updateNavUi() {
      if (!modal) return;

      var canGoBack = diagramNavStack.length > 0;
      modal.btnBack.disabled = !canGoBack;
      if (!canGoBack) {
        modal.btnBack.textContent = 'Back';
        modal.btnBack.setAttribute('title', 'Open a detail view first to enable back');
        modal.btnBack.setAttribute('aria-label', 'Back');
      } else {
        var parent = diagramNavStack[diagramNavStack.length - 1];
        var parentName = getDiagramDisplayName(parent);
        var btnLabel = 'Back to ' + truncateForUi(parentName, 22);
        modal.btnBack.textContent = btnLabel;
        modal.btnBack.setAttribute(
          'title',
          'Return to: ' + parentName + ' (detail depth ' + (diagramNavStack.length + 1) + ')',
        );
        modal.btnBack.setAttribute('aria-label', btnLabel);
      }

      if (!active || !active.focusIndex || !(active.focusIndex.focusNode || active.focusIndex.focusEdge)) {
        if (!canGoBack) {
          updateLiveStatus('Top-level diagram.');
        } else {
          var backParent = diagramNavStack[diagramNavStack.length - 1];
          var backName = getDiagramDisplayName(backParent);
          updateLiveStatus(
            'Detail view: level ' +
              (diagramNavStack.length + 1) +
              ' • Back to ' +
              truncateForUi(backName, 22),
          );
        }
      }
    }

    function switchModalToDiagram(diagramElOrState) {
      var diagramEl = diagramElOrState;
      if (!diagramElOrState) return;
      if (diagramElOrState.diagram && diagramElOrState.diagram instanceof HTMLElement) {
        diagramEl = diagramElOrState.diagram;
      }
      if (!diagramEl) return;
      if (!(diagramEl instanceof HTMLElement)) return;
      if (!modal || !active) {
        openModalForDiagram(diagramEl, active && active.diagram);
        ensureControlsWired();
        return;
      }
      if (active.diagram === diagramEl) return;

      // Restore current diagram (but keep overlay open).
      if (active.focusIndex) clearDiagramFocus(active.focusIndex);
      if (panZoom.svg) restoreSvgAfterInspector(panZoom.svg);

      if (active.nextSibling) active.parent.insertBefore(active.diagram, active.nextSibling);
      else active.parent.appendChild(active.diagram);

      if (active.placeholder && active.placeholder.parentNode) {
        active.placeholder.parentNode.removeChild(active.placeholder);
      }

      active.diagram.className = active.originalClassName;

      // Install new diagram.
      var parent = diagramEl.parentNode;
      var nextSibling = diagramEl.nextSibling;
      var rect = diagramEl.getBoundingClientRect();
      var computed = window.getComputedStyle(diagramEl);

      var placeholder = document.createElement('div');
      placeholder.className = 'diagram-inspector-placeholder';
      placeholder.style.height = rect.height + 'px';
      placeholder.style.marginTop = computed.marginTop;
      placeholder.style.marginBottom = computed.marginBottom;
      placeholder.style.marginLeft = computed.marginLeft;
      placeholder.style.marginRight = computed.marginRight;

      parent.insertBefore(placeholder, diagramEl);

      var originalClassName = diagramEl.className;
      diagramEl.className = originalClassName + ' diagram-inspector-active';

      modal.viewport.appendChild(diagramEl);

      var metadata = getDiagramMetadata(diagramEl);
      var titleBase = metadata.titleBase;

      active = {
        diagram: diagramEl,
        parent: parent,
        nextSibling: nextSibling,
        placeholder: placeholder,
        originalClassName: originalClassName,
        titleBase: titleBase,
        diagramType: metadata.typeLabel,
        diagramId: metadata.sourceId,
        focusIndex: null,
      };

      // Wire up pan/zoom to the SVG.
      panZoom.svg = diagramEl.querySelector('svg');
      if (panZoom.svg) prepareSvgForInspector(panZoom.svg);
      panZoom.scale = 1;
      panZoom.tx = 0;
      panZoom.ty = 0;
      applyTransform();
      fitToViewport();

      // Focus/highlight support (flowcharts). Safe no-op for non-flowchart diagrams.
      var focusIndex = null;
      if (panZoom.svg) {
        focusIndex = focusIndexCache.get(panZoom.svg);
        if (!focusIndex) {
          focusIndex = buildFocusIndex(panZoom.svg);
          if (focusIndex) focusIndexCache.set(panZoom.svg, focusIndex);
        }
        if (focusIndex) wireFocusHandlersForSvg(focusIndex);
      }
      active.focusIndex = focusIndex;
      renderDiagramInfo();
      if (modal && modal.searchInput) {
        modal.searchInput.value = '';
        modal.searchInput.disabled = !focusIndex;
        modal.btnFind.disabled = !focusIndex;
        modal.btnClearFocus.disabled = true;
      }
      updateFocusUi();
    }

    function getDecomposeInfoForNode(nodeKey) {
      if (!nodeKey) return null;
      var diagramId = DECOMPOSE_TO_DIAGRAM_ID[nodeKey];
      if (!diagramId) return null;
      var target = document.querySelector('.mermaid-diagram[data-diagram-id="' + diagramId + '"]');
      if (!(target instanceof HTMLElement)) return null;
      var metadata = getDiagramMetadata(target);
      var title = metadata.titleBase && metadata.titleBase !== 'Diagram inspector' ? metadata.titleBase : metadata.sourceId;
      return {
        diagramId: diagramId,
        diagram: target,
        title: title || 'Diagram',
        typeLabel: metadata.typeLabel || 'Diagram',
      };
    }

    function getDiagramDisplayName(state) {
      if (!state) return 'Previous diagram';
      if (state.titleBase && state.titleBase !== 'Diagram inspector') return state.titleBase;
      if (state.diagramId) return state.diagramId;
      return 'Previous diagram';
    }

    function decomposeNodeKey(nodeKey) {
      if (!active || !nodeKey) {
        updateLiveStatus('Select a node first, then click Decompose.');
        return false;
      }
      var info = getDecomposeInfoForNode(nodeKey);
      if (!info || !(info.diagram instanceof HTMLElement)) {
        updateLiveStatus('No detail mapping for node ' + nodeKey + '.');
        return false;
      }
      var target = info.diagram;

      // Push current diagram to history so Back works.
      diagramNavStack.push({
        diagram: active.diagram,
        titleBase: active.titleBase,
        diagramType: active.diagramType,
        diagramId: active.diagramId,
      });
      switchModalToDiagram(target);
      updateLiveStatus('Opened detail diagram: ' + info.title + ' (' + info.diagramId + ')');
      return true;
    }

    function getDecomposeTargetsForDiagram(index) {
      if (!index || !index.nodes || index.nodes.length === 0) return [];
      var out = [];
      index.nodes.forEach(function (node) {
        if (!node || !node.key) return;
        var info = getDecomposeInfoForNode(node.key);
        if (!info) return;
        out.push({ key: node.key, title: info.title, diagramId: info.diagramId });
      });
      return out;
    }

    function focusNode(index, nodeKey, shouldCenter) {
      if (!index || !nodeKey) return;
      var record = index.nodeByKey.get(nodeKey);
      if (!record) return;

      var nodes = new Set();
      var edges = new Set();
      nodes.add(nodeKey);
      var related = index.edgesByNode.get(nodeKey) || [];
      related.forEach(function (e) {
        edges.add(e.id);
        nodes.add(e.from);
        nodes.add(e.to);
      });

      index.focusNode = nodeKey;
      index.focusEdge = null;
      applyDiagramFocus(index, { nodes: nodes, edges: edges, selectedNode: nodeKey });
      updateFocusUi();

      if (modal && modal.searchInput) modal.searchInput.value = nodeKey;
      if (shouldCenter !== false) centerOnElement(record.el);
    }

    function focusEdge(index, edgeId, shouldCenter) {
      if (!index || !edgeId) return;
      var edge = index.edgeById.get(edgeId);
      if (!edge) return;

      var nodes = new Set();
      var edges = new Set();
      nodes.add(edge.from);
      nodes.add(edge.to);
      edges.add(edge.id);

      index.focusNode = null;
      index.focusEdge = edge.id;
      applyDiagramFocus(index, { nodes: nodes, edges: edges, selectedEdge: edge.id });
      updateFocusUi();

      if (shouldCenter !== false) {
        var labelEl = edge.labelEls && edge.labelEls.length ? edge.labelEls[0] : null;
        centerOnElement(labelEl || edge.pathEl);
      }
    }

    function flashSearchError(message) {
      if (!modal || !modal.searchInput) return;
      if (message) updateLiveStatus(message);
      modal.searchInput.classList.add('diagram-inspector-search-invalid');
      setTimeout(function () {
        if (!modal || !modal.searchInput) return;
        modal.searchInput.classList.remove('diagram-inspector-search-invalid');
      }, 650);
    }

    function findAndFocusFromQuery(query) {
      if (!active || !active.focusIndex) return;
      var index = active.focusIndex;
      var raw = String(query || '').trim();
      if (!raw) {
        var decomposeTargets = getDecomposeTargetsForDiagram(index);
        var decomposedHint = decomposeTargets.length
          ? 'Try mapped nodes: ' + decomposeTargets.slice(0, 4).map(function (item) { return item.key; }).join(', ')
          : '';
        var allNodeHint = index.nodes.slice(0, 4).map(function (node) { return node.key; }).join(', ');
        var extra = decomposedHint ? ' ' + decomposedHint : '';
        var allHint = allNodeHint ? ' (for example: ' + allNodeHint + ')' : '';
        flashSearchError(
          'Enter a node id or label to find.' + extra + allHint,
        );
        return;
      }

      // Try exact key match first (case-insensitive).
      var qNorm = normalizeText(raw);
      var exact = null;
      index.nodeSearch.some(function (n) {
        if (n.keyNorm === qNorm) {
          exact = n.key;
          return true;
        }
        return false;
      });
      if (exact) {
        focusNode(index, exact);
        return;
      }

      // If the input starts with a token that matches a key, prefer that.
      var token = normalizeText(raw.split(/[\s:,-]+/)[0]);
      var tokenMatch = null;
      index.nodeSearch.some(function (n) {
        if (n.keyNorm === token) {
          tokenMatch = n.key;
          return true;
        }
        return false;
      });
      if (tokenMatch) {
        focusNode(index, tokenMatch);
        return;
      }

      // Otherwise, substring match on label, then key.
      var partial = null;
      index.nodeSearch.some(function (n) {
        if (n.labelNorm.indexOf(qNorm) !== -1) {
          partial = n.key;
          return true;
        }
        return false;
      });
      if (!partial) {
        index.nodeSearch.some(function (n) {
          if (n.keyNorm.indexOf(qNorm) !== -1) {
            partial = n.key;
            return true;
          }
          return false;
        });
      }

      if (partial) {
        focusNode(index, partial);
      } else {
        var fallback = index.nodeSearch
          .slice(0, 8)
          .map(function (candidate) {
            return candidate.key;
          })
          .join(', ');
        flashSearchError(
          'No match for: ' + raw + '. Available ids: ' + (fallback || 'none detected.'),
        );
      }
    }

    function findInEventPath(e, predicate) {
      if (!e || typeof predicate !== 'function') return null;
      var path = typeof e.composedPath === 'function' ? e.composedPath() : [];
      for (var i = 0; i < path.length; i++) {
        var el = path[i];
        if (el instanceof Element && predicate(el)) return el;
      }
      return null;
    }

    function wireFocusHandlersForSvg(index) {
      if (!index || index._wired) return;
      index._wired = true;

      index.svg.addEventListener('click', function (e) {
        if (!active || panZoom.svg !== index.svg) return;
        if (panZoom.ignoreClick) return;

        // Node click focuses adjacency.
        var nodeEl = findInEventPath(e, function (el) {
          return el.tagName.toLowerCase() === 'g' && el.classList.contains('node');
        });
        if (nodeEl) {
          var key = parseFlowchartNodeKey(nodeEl.getAttribute('id'));
          if (key) {
            focusNode(index, key);
            return;
          }
        }

        // Edge click focuses endpoints.
        var edgePath = findInEventPath(e, function (el) {
          if (!(el instanceof SVGPathElement)) return false;
          if (!el.classList.contains('flowchart-link')) return false;
          var id = el.getAttribute('id') || '';
          return id.indexOf('L_') === 0;
        });
        if (edgePath) {
          var edgeId = edgePath.getAttribute('id');
          if (edgeId) {
            focusEdge(index, edgeId);
            return;
          }
        }

        var edgeLabel = findInEventPath(e, function (el) {
          if (el.tagName.toLowerCase() !== 'g') return false;
          if (!el.classList.contains('label')) return false;
          return !!el.getAttribute('data-id');
        });
        if (edgeLabel) {
          var edgeId2 = edgeLabel.getAttribute('data-id');
          if (edgeId2) {
            focusEdge(index, edgeId2);
            return;
          }
        }

        // Background clears focus.
        clearDiagramFocus(index);
        updateFocusUi();
      });

      // Right-click: decompose a node into a deeper/alternate diagram (when configured).
      index.svg.addEventListener('contextmenu', function (e) {
        if (!active || panZoom.svg !== index.svg) return;

        var nodeEl = findInEventPath(e, function (el) {
          return el.tagName.toLowerCase() === 'g' && el.classList.contains('node');
        });
        if (!nodeEl) return;

        var key = parseFlowchartNodeKey(nodeEl.getAttribute('id'));
        if (!key) return;

        e.preventDefault();
        e.stopPropagation();
        if (!decomposeNodeKey(key)) focusNode(index, key);
      });
    }

    function fitToViewport() {
      if (!modal || !active || !panZoom.svg) return;

      // Reset first so measurements are stable.
      panZoom.scale = 1;
      panZoom.tx = 0;
      panZoom.ty = 0;
      applyTransform();

      // Use a double-rAF so the SVG has a settled layout after being moved into the modal.
      requestAnimationFrame(function () {
        requestAnimationFrame(function () {
          if (!modal || !active || !panZoom.svg) return;
          var viewportRect = modal.viewport.getBoundingClientRect();
          if (viewportRect.width === 0 || viewportRect.height === 0) return;

          var vb = panZoom.svg.viewBox && panZoom.svg.viewBox.baseVal ? panZoom.svg.viewBox.baseVal : null;
          var svgW = vb && vb.width > 0 ? vb.width : panZoom.svg.getBoundingClientRect().width;
          var svgH = vb && vb.height > 0 ? vb.height : panZoom.svg.getBoundingClientRect().height;
          if (!svgW || !svgH) return;

          var padding = 16;
          var maxW = Math.max(1, viewportRect.width - padding * 2);
          var maxH = Math.max(1, viewportRect.height - padding * 2);

          var scale = Math.min(maxW / svgW, maxH / svgH);
          scale = clamp(scale, 0.2, 6);

          var tx = (viewportRect.width - svgW * scale) / 2;
          var ty = (viewportRect.height - svgH * scale) / 2;

          panZoom.scale = scale;
          panZoom.tx = tx;
          panZoom.ty = ty;
          applyTransform();
        });
      });
    }

    function zoomAt(viewportX, viewportY, factor) {
      if (!modal || !active || !panZoom.svg) return;

      var newScale = clamp(panZoom.scale * factor, 0.2, 6);
      if (newScale === panZoom.scale) return;

      var x = (viewportX - panZoom.tx) / panZoom.scale;
      var y = (viewportY - panZoom.ty) / panZoom.scale;

      panZoom.tx = viewportX - x * newScale;
      panZoom.ty = viewportY - y * newScale;
      panZoom.scale = newScale;
      applyTransform();
    }

    function closeModal() {
      if (!modal || !active) return;

      // Ensure we don't leave a focused/dimmed state behind when restoring inline.
      if (active.focusIndex) {
        clearDiagramFocus(active.focusIndex);
      }

      if (panZoom.svg) restoreSvgAfterInspector(panZoom.svg);

      // Restore diagram to original location.
      if (active.nextSibling) active.parent.insertBefore(active.diagram, active.nextSibling);
      else active.parent.appendChild(active.diagram);

      if (active.placeholder && active.placeholder.parentNode) {
        active.placeholder.parentNode.removeChild(active.placeholder);
      }

      active.diagram.className = active.originalClassName;

      modal.overlay.setAttribute('data-open', 'false');
      modal.overlay.setAttribute('aria-hidden', 'true');
      document.body.style.overflow = '';

      // Reset state
      panZoom.svg = null;
      panZoom.pointers.clear();
      panZoom.dragStart = null;
      panZoom.pinchStart = null;
      panZoom.ignoreClick = false;

      if (modal && modal.searchInput) {
        modal.searchInput.value = '';
        modal.searchInput.disabled = true;
        modal.btnFind.disabled = true;
        modal.btnClearFocus.disabled = true;
        modal.btnDecompose.disabled = true;
      }

      diagramNavStack.length = 0;
      updateNavUi();

      active = null;

      if (modalReturnTarget && modalReturnTarget.isConnected) {
        try {
          modalReturnTarget.focus();
        } catch {
          // ignore
        }
      }
      modalReturnTarget = null;
    }

    function openModalForDiagram(diagramEl, openerEl) {
      if (!modal) modal = createModal();
      if (active) closeModal();
      diagramNavStack.length = 0;
      updateNavUi();
      modalReturnTarget = openerEl instanceof HTMLElement ? openerEl : document.activeElement;

      // Save original placement so we can restore.
      var parent = diagramEl.parentNode;
      var nextSibling = diagramEl.nextSibling;
      var rect = diagramEl.getBoundingClientRect();
      var computed = window.getComputedStyle(diagramEl);

      var placeholder = document.createElement('div');
      placeholder.className = 'diagram-inspector-placeholder';
      placeholder.style.height = rect.height + 'px';
      placeholder.style.marginTop = computed.marginTop;
      placeholder.style.marginBottom = computed.marginBottom;
      placeholder.style.marginLeft = computed.marginLeft;
      placeholder.style.marginRight = computed.marginRight;

      parent.insertBefore(placeholder, diagramEl);

      var originalClassName = diagramEl.className;
      diagramEl.className = originalClassName + ' diagram-inspector-active';

      // Move the diagram into the modal viewport.
      modal.viewport.appendChild(diagramEl);

      // Update title if we can infer something useful.
      var metadata = getDiagramMetadata(diagramEl);
      var titleBase = metadata.titleBase;

      active = {
        diagram: diagramEl,
        parent: parent,
        nextSibling: nextSibling,
        placeholder: placeholder,
        originalClassName: originalClassName,
        titleBase: titleBase,
        diagramType: metadata.typeLabel,
        diagramId: metadata.sourceId,
        focusIndex: null,
      };

      modal.overlay.setAttribute('data-open', 'true');
      modal.overlay.setAttribute('aria-hidden', 'false');
      document.body.style.overflow = 'hidden';

      // Wire up pan/zoom to the SVG.
      panZoom.svg = diagramEl.querySelector('svg');
      if (panZoom.svg) prepareSvgForInspector(panZoom.svg);
      panZoom.scale = 1;
      panZoom.tx = 0;
      panZoom.ty = 0;
      applyTransform();
      fitToViewport();

      // Focus/highlight support (flowcharts). Safe no-op for non-flowchart diagrams.
      var focusIndex = null;
      if (panZoom.svg) {
        focusIndex = focusIndexCache.get(panZoom.svg);
        if (!focusIndex) {
          focusIndex = buildFocusIndex(panZoom.svg);
          if (focusIndex) focusIndexCache.set(panZoom.svg, focusIndex);
        }
        if (focusIndex) wireFocusHandlersForSvg(focusIndex);
      }
      active.focusIndex = focusIndex;
      renderDiagramInfo();
      if (modal && modal.searchInput) {
        modal.searchInput.value = '';
        modal.searchInput.disabled = !focusIndex;
        modal.btnFind.disabled = !focusIndex;
        modal.btnClearFocus.disabled = true;
      }
      updateFocusUi();
      updateNavUi();

      // Focus an initial control for keyboard users.
      requestAnimationFrame(function () {
        focusInitialInspectorControl();
      });
    }

    function ensureControlsWired() {
      if (!modal) return;
      if (modal._wired) return;
      modal._wired = true;

      // Close on overlay click (outside dialog)
      modal.overlay.addEventListener('click', function (e) {
        if (e.target === modal.overlay) closeModal();
      });

      // Keyboard actions while the inspector is open.
      document.addEventListener('keydown', function (e) {
        if (!active) return;
        if (e.key === 'Escape') {
          closeModal();
          return;
        }

        if (e.key === 'Tab') {
          var focusables = getInspectorFocusableElements();
          if (focusables.length === 0) {
            e.preventDefault();
            return;
          }

          var activeElement = document.activeElement;
          var index = focusables.indexOf(activeElement);
          if (index === -1) index = 0;
          var delta = e.shiftKey ? -1 : 1;
          var next = index + delta;
          if (next < 0) next = focusables.length - 1;
          if (next >= focusables.length) next = 0;

          focusables[next].focus();
          e.preventDefault();
          return;
        }

        var lower = e.key.toLowerCase();
        var inTextInput = isTextInputTarget(e.target);

        // / is intentionally reserved to jump to search.
        if (!inTextInput && (lower === 'f' || lower === '/')) {
          e.preventDefault();
          if (modal && modal.searchInput) {
            modal.searchInput.focus();
            modal.searchInput.select();
          }
          return;
        }

        if (inTextInput) return;

        if (lower === 'r') {
          panZoom.scale = 1;
          panZoom.tx = 0;
          panZoom.ty = 0;
          applyTransform();
          fitToViewport();
          return;
        }

        if (lower === '0') {
          fitToViewport();
          return;
        }

        if (e.key === '+' || e.key === '=') {
          e.preventDefault();
          if (modal) {
            var r = modal.viewport.getBoundingClientRect();
            zoomAt(r.width / 2, r.height / 2, 1.2);
          }
          return;
        }

        if (e.key === '-' || e.key === '_') {
          e.preventDefault();
          if (modal) {
            var r2 = modal.viewport.getBoundingClientRect();
            zoomAt(r2.width / 2, r2.height / 2, 1 / 1.2);
          }
          return;
        }

        if (lower === 'c' && active.focusIndex && (active.focusIndex.focusNode || active.focusIndex.focusEdge)) {
          clearDiagramFocus(active.focusIndex);
          updateFocusUi();
        }
      });

      // Buttons
      modal.dialog.addEventListener('click', function (e) {
        var target = e.target;
        if (!(target instanceof HTMLElement)) return;
        var action = target.getAttribute('data-action');
        if (!action) return;

        if (action === 'close') closeModal();
        else if (action === 'back') {
          if (diagramNavStack.length === 0) {
            updateLiveStatus('No previous diagram in stack. Open a mapped node to decompose first.');
            return;
          }
          var prev = diagramNavStack.pop();
          switchModalToDiagram(prev);
          updateLiveStatus(
            'Returned to ' +
              truncateForUi((prev && getDiagramDisplayName(prev)) || 'previous diagram', 24),
          );
        }
        else if (action === 'decompose') {
          if (active && active.focusIndex && active.focusIndex.focusNode) {
            decomposeNodeKey(active.focusIndex.focusNode);
          }
          else {
            updateLiveStatus('Focus a node first, then click decompose.');
          }
        }
        else if (action === 'clearFocus') {
          if (active && active.focusIndex) {
            clearDiagramFocus(active.focusIndex);
            updateFocusUi();
          }
        } else if (action === 'find') {
          if (modal && modal.searchInput) findAndFocusFromQuery(modal.searchInput.value);
        }
        else if (action === 'fit') fitToViewport();
        else if (action === 'reset') {
          panZoom.scale = 1;
          panZoom.tx = 0;
          panZoom.ty = 0;
          applyTransform();
          fitToViewport();
        } else if (action === 'zoomIn' && modal) {
          var r = modal.viewport.getBoundingClientRect();
          zoomAt(r.width / 2, r.height / 2, 1.2);
        } else if (action === 'zoomOut' && modal) {
          var r2 = modal.viewport.getBoundingClientRect();
          zoomAt(r2.width / 2, r2.height / 2, 1 / 1.2);
        }
      });

      // Wheel zoom
      modal.viewport.addEventListener(
        'wheel',
        function (e) {
          if (!active) return;
          e.preventDefault();
          var rect = modal.viewport.getBoundingClientRect();
          var x = e.clientX - rect.left;
          var y = e.clientY - rect.top;
          var factor = e.deltaY > 0 ? 1 / 1.12 : 1.12;
          zoomAt(x, y, factor);
        },
        { passive: false },
      );

      // Pointer-based pan/zoom (drag + pinch)
      modal.viewport.addEventListener('pointerdown', function (e) {
        if (!active) return;
        // Ignore non-primary mouse buttons so right-click can be used for decomposition.
        if (e.pointerType === 'mouse' && e.button !== 0) return;
        modal.viewport.setPointerCapture(e.pointerId);
        panZoom.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
        panZoom.ignoreClick = false;

        if (panZoom.pointers.size === 1) {
          panZoom.dragStart = {
            x: e.clientX,
            y: e.clientY,
            tx: panZoom.tx,
            ty: panZoom.ty,
          };
          modal.viewport.classList.add('diagram-inspector-dragging');
        } else if (panZoom.pointers.size === 2) {
          var pts = Array.from(panZoom.pointers.values());
          var dx = pts[0].x - pts[1].x;
          var dy = pts[0].y - pts[1].y;
          var dist = Math.sqrt(dx * dx + dy * dy);
          var centerX = (pts[0].x + pts[1].x) / 2;
          var centerY = (pts[0].y + pts[1].y) / 2;

          var viewportRect = modal.viewport.getBoundingClientRect();
          var cx = centerX - viewportRect.left;
          var cy = centerY - viewportRect.top;

          panZoom.pinchStart = {
            dist: dist,
            centerX: cx,
            centerY: cy,
            scale: panZoom.scale,
            tx: panZoom.tx,
            ty: panZoom.ty,
            anchorX: (cx - panZoom.tx) / panZoom.scale,
            anchorY: (cy - panZoom.ty) / panZoom.scale,
          };

          panZoom.dragStart = null;
        }
      });

      modal.viewport.addEventListener('pointermove', function (e) {
        if (!active) return;
        if (!panZoom.pointers.has(e.pointerId)) return;
        panZoom.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

        if (panZoom.pointers.size === 1 && panZoom.dragStart) {
          // If we moved, treat this pointer sequence as a drag, not a click.
          var dx1 = e.clientX - panZoom.dragStart.x;
          var dy1 = e.clientY - panZoom.dragStart.y;
          if (Math.sqrt(dx1 * dx1 + dy1 * dy1) > 6) panZoom.ignoreClick = true;
          panZoom.tx = panZoom.dragStart.tx + (e.clientX - panZoom.dragStart.x);
          panZoom.ty = panZoom.dragStart.ty + (e.clientY - panZoom.dragStart.y);
          applyTransform();
          return;
        }

        if (panZoom.pointers.size === 2 && panZoom.pinchStart && modal) {
          panZoom.ignoreClick = true;
          var pts = Array.from(panZoom.pointers.values());
          var dx = pts[0].x - pts[1].x;
          var dy = pts[0].y - pts[1].y;
          var dist = Math.sqrt(dx * dx + dy * dy);

          var centerX = (pts[0].x + pts[1].x) / 2;
          var centerY = (pts[0].y + pts[1].y) / 2;
          var viewportRect = modal.viewport.getBoundingClientRect();
          var cx = centerX - viewportRect.left;
          var cy = centerY - viewportRect.top;

          var factor = dist / panZoom.pinchStart.dist;
          var newScale = clamp(panZoom.pinchStart.scale * factor, 0.2, 6);

          panZoom.scale = newScale;
          panZoom.tx = cx - panZoom.pinchStart.anchorX * newScale;
          panZoom.ty = cy - panZoom.pinchStart.anchorY * newScale;
          applyTransform();
        }
      });

      function onPointerEnd(e) {
        if (!active) return;
        if (!panZoom.pointers.has(e.pointerId)) return;
        panZoom.pointers.delete(e.pointerId);

        if (panZoom.pointers.size === 0) {
          panZoom.dragStart = null;
          panZoom.pinchStart = null;
          modal.viewport.classList.remove('diagram-inspector-dragging');

          // Prevent a click-after-drag from triggering focus changes.
          if (panZoom.ignoreClick) {
            setTimeout(function () {
              panZoom.ignoreClick = false;
            }, 0);
          }
        } else if (panZoom.pointers.size === 1) {
          // Transition from pinch to drag.
          var pt = Array.from(panZoom.pointers.values())[0];
          panZoom.dragStart = { x: pt.x, y: pt.y, tx: panZoom.tx, ty: panZoom.ty };
          panZoom.pinchStart = null;
        }
      }

      modal.viewport.addEventListener('pointerup', onPointerEnd);
      modal.viewport.addEventListener('pointercancel', onPointerEnd);
      modal.viewport.addEventListener('pointerleave', onPointerEnd);

      // Ensure explicit close button works even if event delegation above changes.
      modal.btnClose.addEventListener('click', closeModal);

      // Search input: Enter triggers find.
      if (modal.searchInput) {
        modal.searchInput.addEventListener('keydown', function (e) {
          if (e.key === 'Enter') {
            e.preventDefault();
            findAndFocusFromQuery(modal.searchInput.value);
          }
        });
      }
    }

    function isTextInputTarget(target) {
      if (!target || !(target instanceof HTMLElement)) return false;
      if (target.isContentEditable) return true;
      var tag = target.tagName;
      if (!tag) return false;
      tag = tag.toLowerCase();
      return tag === 'input' || tag === 'textarea' || tag === 'select';
    }

    function getInspectorFocusableElements() {
      if (!modal || !modal.dialog) return [];
      var selector = [
        'button:not([disabled])',
        'a[href]:not([disabled])',
        'input:not([disabled])',
        'textarea:not([disabled])',
        'select:not([disabled])',
        '[tabindex]:not([disabled]):not([tabindex="-1"])',
      ].join(',');
      var nodes = modal.dialog.querySelectorAll(selector);
      var out = [];
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (!(node instanceof HTMLElement)) continue;
        if (node.offsetParent === null) continue;
        out.push(node);
      }
      return out;
    }

    function focusInitialInspectorControl() {
      if (!modal || !active) return;
      var focusables = getInspectorFocusableElements();
      if (focusables.length === 0) return;
      focusables[0].focus();
    }

    function enhanceMermaidDiagrams() {
      var diagrams = document.querySelectorAll('.mermaid-diagram');
      if (diagrams.length === 0) return;

      diagrams.forEach(function (diagram) {
        repairMermaidNodeIcons(diagram);
        if (!(diagram instanceof HTMLElement)) return;
        if (diagram.querySelector('.diagram-fullscreen-trigger')) return;

        // Ensure a stable stacking context for the button.
        diagram.classList.add('diagram-has-overlay');

        var btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'diagram-fullscreen-trigger';
        btn.textContent = 'Fullscreen';
        btn.setAttribute('aria-label', 'Open diagram fullscreen');

        btn.addEventListener('click', function () {
          openModalForDiagram(diagram, btn);
          ensureControlsWired();
        });

        // Double-click on the diagram also opens the inspector.
        diagram.addEventListener('dblclick', function () {
          openModalForDiagram(diagram, diagram);
          ensureControlsWired();
        });

        // Right-click on a node opens fullscreen and decomposes when available.
        diagram.addEventListener('contextmenu', function (e) {
          var nodeEl = findInEventPath(e, function (el) {
            return el.tagName.toLowerCase() === 'g' && el.classList.contains('node');
          });
          if (!nodeEl) return;

          var key = parseFlowchartNodeKey(nodeEl.getAttribute('id'));
          if (!key) return;

          e.preventDefault();
          openModalForDiagram(diagram, diagram);
          ensureControlsWired();
          if (active && active.focusIndex) {
            if (!decomposeNodeKey(key)) focusNode(active.focusIndex, key);
          }
        });

        diagram.appendChild(btn);
      });
    }

    function normalizeRenderedMermaidSvgSizing() {
      var svgs = document.querySelectorAll('.mermaid-diagram svg');
      if (svgs.length === 0) return;
      svgs.forEach(function (svg) {
        if (!(svg instanceof SVGElement)) return;
        var vb = svg.getAttribute('viewBox');
        if (vb) {
          var parts = vb.trim().split(/\s+/);
          if (parts.length === 4) {
            var width = parseFloat(parts[2]);
            if (!Number.isNaN(width) && width > 0) {
              svg.setAttribute('width', String(width));
              svg.removeAttribute('height');
            }
          }
        }
      });
    }

    function loadMermaidWithFallback(index) {
      return new Promise(function (resolve, reject) {
        var candidate = MERMAID_CDN_CANDIDATES[index];
        if (!candidate) {
          reject(new Error('Unable to load Mermaid script.'));
          return;
        }

        var existing = document.querySelector('script[data-mermaid-client]');
        var script = existing || document.createElement('script');
        if (!existing) {
          script.setAttribute('data-mermaid-client', 'true');
          script.src = candidate;
        } else if (!existing.src) {
          script.src = candidate;
        }

        function onError() {
          if (script.parentNode) script.parentNode.removeChild(script);
          loadMermaidWithFallback(index + 1).then(resolve, reject);
        }

        if (existing) {
          if (window.mermaid) {
            setMermaidAssetBaseFromScript(existing.src);
            resolve();
            return;
          }
          if (existing.readyState === 'loaded' || existing.readyState === 'complete') {
            onError();
            return;
          }
          existing.addEventListener(
            'load',
            function () {
              if (window.mermaid) {
                setMermaidAssetBaseFromScript(existing.src);
                resolve();
              } else {
                onError();
              }
            },
            { once: true }
          );
          existing.addEventListener('error', onError, { once: true });
          return;
        }

        script.onload = function () {
          if (window.mermaid) {
            setMermaidAssetBaseFromScript(script.src);
            resolve();
            return;
          }
          onError();
        };
        script.onerror = onError;
        document.head.appendChild(script);
      });
    }

    function runMermaid() {
      // Mermaid script loads asynchronously and provides window.mermaid.
      var isDark = document.documentElement.classList.contains('dark');

      window.mermaid.initialize({
        startOnLoad: false,
        theme: isDark ? 'dark' : 'default',
        securityLevel: 'loose',
        flowchart: { useMaxWidth: true, htmlLabels: true, padding: 16 },
        sequence: { useMaxWidth: true },
      });

      preBlocks.forEach(function (pre, index) {
        var sourceText = normalizeMermaidSourceIcons(pre.textContent || '');
        var container = document.createElement('div');
        container.className = 'mermaid-diagram my-6';
        container.id = 'mermaid-diagram-' + index;
        container.setAttribute('data-mermaid-source', sourceText);
        var diagramId = extractDiagramIdFromSource(sourceText);
        if (diagramId) container.setAttribute('data-diagram-id', diagramId);
        container.textContent = sourceText;
        pre.parentElement.replaceChild(container, pre);
      });

      var runResult = window.mermaid.run({ querySelector: '.mermaid-diagram' });
      if (isThenable(runResult)) {
        runResult
          .then(function () {
            normalizeRenderedMermaidSvgSizing();
            enhanceMermaidDiagrams();
          })
          .catch(function () {
            normalizeRenderedMermaidSvgSizing();
            enhanceMermaidDiagrams();
          });
      } else {
        // Mermaid might run synchronously; defer enhancement to next tick.
        setTimeout(function () {
          normalizeRenderedMermaidSvgSizing();
          enhanceMermaidDiagrams();
        }, 0);
      }
    }

    function runMermaidSafely() {
      try {
        runMermaid();
        return true;
      } catch (_error) {
        return false;
      }
    }

    // If build-time rendering has already emitted .mermaid-diagram blocks, only bind controls.
    var renderedDiagrams = document.querySelectorAll('.mermaid-diagram[data-mermaid-source]');
    if (renderedDiagrams.length > 0 && preBlocks.length === 0) {
      setTimeout(function () {
        normalizeRenderedMermaidSvgSizing();
        enhanceMermaidDiagrams();
      }, 0);
      return;
    }

    // No rendered diagrams and no source blocks means this page has nothing to enhance.
    if (preBlocks.length === 0) {
      return;
    }

    // Load Mermaid only on pages that include mermaid code blocks.
    var existing = document.querySelector('script[data-mermaid-client]');
    if (existing && window.mermaid) {
      setMermaidAssetBaseFromScript(existing.src);
      if (!runMermaidSafely()) {
        showMermaidSourceFallback();
      }
      return;
    }

    loadMermaidWithFallback(0)
      .then(function () {
        if (window.mermaid) {
          if (!runMermaidSafely()) {
            showMermaidSourceFallback();
          }
          return;
        }
        showMermaidSourceFallback();
      })
      .catch(function () {
        if (window.mermaid) {
          if (!runMermaidSafely()) {
            showMermaidSourceFallback();
          }
          return;
        }
        showMermaidSourceFallback();
      });
  });
</script>
